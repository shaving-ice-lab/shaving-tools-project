# æ‰‹æœºè¯„æµ‹å·¥å…· - æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®æ€»è§ˆ

åŸºäº **Turborepo** monorepo æ¶æ„ï¼Œä½¿ç”¨ **Next.js + TypeScript + React** æ„å»ºã€‚

---

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

```
shaving-tools-project/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ web/                    # ä¸»Webåº”ç”¨ï¼ˆNext.jsï¼‰
â”‚   â”œâ”€â”€ screen-test/            # å±å¹•æµ‹è¯•å·¥å…·
â”‚   â”œâ”€â”€ camera-analyzer/        # ç›¸æœºåˆ†æå·¥å…·
â”‚   â””â”€â”€ performance-monitor/    # æ€§èƒ½ç›‘æ§Appï¼ˆReact Nativeï¼‰
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ ui/                     # å…±äº«UIç»„ä»¶åº“
â”‚   â”œâ”€â”€ utils/                  # å·¥å…·å‡½æ•°åº“
â”‚   â”œâ”€â”€ database/               # æ•°æ®åº“Schemaå’Œæ“ä½œ
â”‚   â”œâ”€â”€ api-client/             # APIå®¢æˆ·ç«¯
â”‚   â””â”€â”€ config/                 # å…±äº«é…ç½®
â””â”€â”€ services/
    â”œâ”€â”€ api/                    # åç«¯APIæœåŠ¡
    â””â”€â”€ data-crawler/           # æ•°æ®çˆ¬è™«æœåŠ¡
```

---

## ğŸ¯ é¡¹ç›®ä¸€ï¼šå±å¹•æµ‹è¯•å·¥å…·ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰

### åŠŸèƒ½æ¨¡å—è®¾è®¡

#### 1.1 çº¯è‰²æµ‹è¯•æ¨¡å—
```typescript
interface ColorTestConfig {
  colors: string[];           // æµ‹è¯•é¢œè‰²åˆ—è¡¨
  duration: number;           // æ¯ä¸ªé¢œè‰²åœç•™æ—¶é—´ï¼ˆç§’ï¼‰
  autoSwitch: boolean;        // è‡ªåŠ¨åˆ‡æ¢
  brightness: number;         // å±å¹•äº®åº¦ï¼ˆ0-100ï¼‰
}

// å®ç°æ–¹æ¡ˆ
class ColorTest {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  
  // ç»˜åˆ¶çº¯è‰²èƒŒæ™¯
  drawColor(color: string) {
    this.ctx.fillStyle = color;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  // å…¨å±æ¨¡å¼
  enterFullscreen() {
    this.canvas.requestFullscreen();
  }
  
  // åç‚¹æ£€æµ‹åºåˆ—
  deadPixelTest() {
    const colors = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF'];
    // æ¯ä¸ªé¢œè‰²åœç•™3ç§’
  }
}
```

#### 1.2 ç°é˜¶æµ‹è¯•æ¨¡å—
```typescript
interface GrayscaleConfig {
  levels: number;             // ç°é˜¶çº§æ•°ï¼ˆé»˜è®¤256ï¼‰
  pattern: 'gradient' | 'blocks';
}

class GrayscaleTest {
  // ç”Ÿæˆç°é˜¶æ¸å˜
  generateGradient(levels: number) {
    const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, 0);
    for (let i = 0; i <= levels; i++) {
      const stop = i / levels;
      const gray = Math.floor(stop * 255);
      gradient.addColorStop(stop, `rgb(${gray},${gray},${gray})`);
    }
    return gradient;
  }
  
  // ç”Ÿæˆç°é˜¶è‰²å—
  generateBlocks(levels: number) {
    const blockWidth = this.canvas.width / levels;
    for (let i = 0; i < levels; i++) {
      const gray = Math.floor((i / levels) * 255);
      this.ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
      this.ctx.fillRect(i * blockWidth, 0, blockWidth, this.canvas.height);
    }
  }
}
```

#### 1.3 å“åº”æ—¶é—´æµ‹è¯•ï¼ˆæ‹–å½±æµ‹è¯•ï¼‰
```typescript
interface ResponseTimeTest {
  objectSpeed: number;        // ç§»åŠ¨é€Ÿåº¦ï¼ˆpx/frameï¼‰
  objectSize: number;         // ç‰©ä½“å¤§å°
  backgroundColor: string;
  foregroundColor: string;
}

class ResponseTimeTest {
  private animationId: number;
  private position: number = 0;
  
  // ç§»åŠ¨æ–¹å—æµ‹è¯•
  startTest() {
    const animate = () => {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // èƒŒæ™¯
      this.ctx.fillStyle = this.config.backgroundColor;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      
      // ç§»åŠ¨çš„æ–¹å—
      this.ctx.fillStyle = this.config.foregroundColor;
      this.ctx.fillRect(this.position, 100, this.config.objectSize, this.config.objectSize);
      
      this.position += this.config.objectSpeed;
      if (this.position > this.canvas.width) this.position = -this.config.objectSize;
      
      this.animationId = requestAnimationFrame(animate);
    };
    animate();
  }
  
  // UFOæµ‹è¯•ï¼ˆç»å…¸æ‹–å½±æµ‹è¯•ï¼‰
  ufoTest() {
    // é»‘ç™½UFOå›¾æ¡ˆé«˜é€Ÿç§»åŠ¨
  }
}
```

#### 1.4 åˆ·æ–°ç‡æµ‹è¯•
```typescript
class RefreshRateTest {
  private frameCount: number = 0;
  private lastTime: number = performance.now();
  private fps: number = 0;
  
  // å®æ—¶FPSè®¡ç®—
  calculateFPS() {
    this.frameCount++;
    const currentTime = performance.now();
    const elapsed = currentTime - this.lastTime;
    
    if (elapsed >= 1000) {
      this.fps = Math.round((this.frameCount * 1000) / elapsed);
      this.frameCount = 0;
      this.lastTime = currentTime;
    }
    
    return this.fps;
  }
  
  // ä½¿ç”¨requestAnimationFrameæ£€æµ‹åˆ·æ–°ç‡
  detectRefreshRate(): Promise<number> {
    return new Promise((resolve) => {
      let frames = 0;
      const startTime = performance.now();
      
      const measure = () => {
        frames++;
        const elapsed = performance.now() - startTime;
        
        if (elapsed >= 1000) {
          resolve(Math.round(frames));
        } else {
          requestAnimationFrame(measure);
        }
      };
      
      requestAnimationFrame(measure);
    });
  }
}
```

#### 1.5 PWMé¢‘é—ªæ£€æµ‹ï¼ˆæ¨¡æ‹Ÿï¼‰
```typescript
class PWMTest {
  // ä½äº®åº¦ä¸‹çš„é¢‘é—ªæ¨¡æ‹Ÿ
  simulatePWM(frequency: number, dutyCycle: number) {
    const period = 1000 / frequency; // ms
    let isOn = true;
    
    setInterval(() => {
      isOn = !isOn;
      this.canvas.style.opacity = isOn ? '1' : '0';
    }, period * dutyCycle);
  }
  
  // æç¤ºç”¨æˆ·ä½¿ç”¨ç›¸æœºæ£€æµ‹
  cameraDetectionGuide() {
    return {
      title: "ä½¿ç”¨ç›¸æœºæ£€æµ‹PWMé¢‘é—ª",
      steps: [
        "1. å°†æ‰‹æœºå±å¹•äº®åº¦è°ƒè‡³æœ€ä½",
        "2. æ‰“å¼€å¦ä¸€å°æ‰‹æœºçš„ç›¸æœº",
        "3. å¯¹å‡†å±å¹•æŸ¥çœ‹æ˜¯å¦æœ‰æ¡çº¹",
        "4. æœ‰æ¡çº¹è¯´æ˜ä½¿ç”¨PWMè°ƒå…‰"
      ]
    };
  }
}
```

#### 1.6 è‰²åŸŸæµ‹è¯•
```typescript
interface ColorGamutTest {
  standard: 'sRGB' | 'DCI-P3' | 'Rec.2020';
}

class ColorGamutTest {
  // æ˜¾ç¤ºæ ‡å‡†è‰²å—
  displayColorPatches() {
    const sRGBColors = [
      { name: 'Red', rgb: [255, 0, 0] },
      { name: 'Green', rgb: [0, 255, 0] },
      { name: 'Blue', rgb: [0, 0, 255] },
      { name: 'Cyan', rgb: [0, 255, 255] },
      { name: 'Magenta', rgb: [255, 0, 255] },
      { name: 'Yellow', rgb: [255, 255, 0] }
    ];
    
    // ç»˜åˆ¶è‰²å—ç½‘æ ¼
    sRGBColors.forEach((color, index) => {
      const x = (index % 3) * 200;
      const y = Math.floor(index / 3) * 200;
      this.ctx.fillStyle = `rgb(${color.rgb.join(',')})`;
      this.ctx.fillRect(x, y, 200, 200);
    });
  }
  
  // è‰²å½©æ¸å˜æµ‹è¯•
  colorGradientTest() {
    // çº¢-ç»¿-è“æ¸å˜ï¼Œæ£€æµ‹è‰²å½©è¿‡æ¸¡æ˜¯å¦å¹³æ»‘
  }
}
```

### æŠ€æœ¯æ ˆ

```json
{
  "framework": "Next.js 14",
  "language": "TypeScript",
  "ui": "Tailwind CSS + shadcn/ui",
  "canvas": "HTML5 Canvas API",
  "storage": "localStorage (æµ‹è¯•è®°å½•)",
  "pwa": "next-pwa (æ”¯æŒç¦»çº¿ä½¿ç”¨)"
}
```

### APIè®¾è®¡

```typescript
// æµ‹è¯•ç»“æœæ•°æ®ç»“æ„
interface TestResult {
  id: string;
  deviceInfo: {
    userAgent: string;
    screenWidth: number;
    screenHeight: number;
    pixelRatio: number;
    colorDepth: number;
  };
  testType: 'color' | 'grayscale' | 'response' | 'refresh' | 'pwm';
  result: {
    passed: boolean;
    notes?: string;
    screenshot?: string;
  };
  timestamp: number;
}

// ä¿å­˜æµ‹è¯•ç»“æœ
POST /api/test-results
Body: TestResult

// è·å–æµ‹è¯•å†å²
GET /api/test-results?deviceId={deviceId}
```

---

## ğŸ¯ é¡¹ç›®äºŒï¼šæ€§èƒ½è·‘åˆ†å¯¹æ¯”å¹³å°

### æ•°æ®åº“è®¾è®¡

```typescript
// Prisma Schema
model Device {
  id            String   @id @default(cuid())
  brand         String
  model         String
  releaseDate   DateTime
  price         Float?
  
  // ç¡¬ä»¶è§„æ ¼
  chipset       Chipset  @relation(fields: [chipsetId], references: [id])
  chipsetId     String
  ram           Int      // MB
  storage       Int      // GB
  screen        Screen?
  camera        Camera?
  battery       Int      // mAh
  
  // è·‘åˆ†æ•°æ®
  benchmarks    Benchmark[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Chipset {
  id            String   @id @default(cuid())
  name          String   @unique
  manufacturer  String   // Qualcomm, MediaTek, Apple, etc.
  process       String   // "4nm", "3nm"
  
  // CPUé…ç½®
  cpuCores      Json     // [{type: "Cortex-X4", cores: 1, maxFreq: 3.3}]
  
  // GPU
  gpu           String
  
  // AI
  npu           String?
  
  devices       Device[]
  scores        ChipsetScore?
}

model Benchmark {
  id            String   @id @default(cuid())
  deviceId      String
  device        Device   @relation(fields: [deviceId], references: [id])
  
  // è·‘åˆ†ç±»å‹
  platform      String   // "AnTuTu", "GeekBench", "3DMark"
  version       String   // ç‰ˆæœ¬å·
  
  // åˆ†æ•°
  totalScore    Int
  cpuScore      Int?
  gpuScore      Int?
  memScore      Int?
  uxScore       Int?
  
  // è¯¦ç»†æ•°æ®
  details       Json?
  
  // æ¥æº
  source        String   // "official", "user_submitted"
  verified      Boolean  @default(false)
  
  createdAt     DateTime @default(now())
}

model Screen {
  id            String   @id @default(cuid())
  deviceId      String   @unique
  device        Device   @relation(fields: [deviceId], references: [id])
  
  size          Float    // è‹±å¯¸
  resolution    String   // "2400x1080"
  ppi           Int
  refreshRate   Int
  touchSampling Int?
  panelType     String   // "AMOLED", "LCD"
  peakBrightness Int?    // nits
  colorGamut    String?  // "DCI-P3 100%"
}
```

### APIè®¾è®¡

```typescript
// è·å–è®¾å¤‡åˆ—è¡¨ï¼ˆå¸¦åˆ†é¡µå’Œç­›é€‰ï¼‰
GET /api/devices
Query: {
  page: number;
  limit: number;
  brand?: string;
  priceMin?: number;
  priceMax?: number;
  chipset?: string;
  sortBy?: 'price' | 'score' | 'releaseDate';
  sortOrder?: 'asc' | 'desc';
}
Response: {
  data: Device[];
  total: number;
  page: number;
  pageCount: number;
}

// è·å–å•ä¸ªè®¾å¤‡è¯¦æƒ…
GET /api/devices/:id
Response: Device & {
  benchmarks: Benchmark[];
  ranking: {
    overall: number;
    samePrice: number;
  };
  similarDevices: Device[];
}

// å¯¹æ¯”å¤šä¸ªè®¾å¤‡
POST /api/devices/compare
Body: {
  deviceIds: string[];
}
Response: {
  devices: Device[];
  comparison: {
    benchmarks: ComparisonChart;
    specs: SpecComparison;
  };
}

// è·å–èŠ¯ç‰‡æ’è¡Œæ¦œ
GET /api/chipsets/ranking
Query: {
  platform: 'AnTuTu' | 'GeekBench';
  limit?: number;
}
Response: {
  ranking: Array<{
    chipset: Chipset;
    averageScore: number;
    deviceCount: number;
  }>;
}
```

### æ•°æ®çˆ¬è™«å®ç°

```typescript
// services/data-crawler/src/scrapers/antutu.ts
class AnTuTuScraper {
  private baseUrl = 'https://www.antutu.com';
  
  // çˆ¬å–æ’è¡Œæ¦œ
  async scrapeRanking() {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    await page.goto(`${this.baseUrl}/ranking/rank1.htm`);
    
    const devices = await page.evaluate(() => {
      const rows = document.querySelectorAll('.rank-item');
      return Array.from(rows).map(row => ({
        rank: row.querySelector('.rank')?.textContent,
        name: row.querySelector('.name')?.textContent,
        score: parseInt(row.querySelector('.score')?.textContent || '0')
      }));
    });
    
    await browser.close();
    return devices;
  }
  
  // çˆ¬å–è®¾å¤‡è¯¦æƒ…
  async scrapeDeviceDetail(deviceId: string) {
    // å®ç°ç»†èŠ‚...
  }
}

// å®šæ—¶ä»»åŠ¡
import { CronJob } from 'cron';

const job = new CronJob('0 0 * * *', async () => {
  console.log('å¼€å§‹æ›´æ–°è·‘åˆ†æ•°æ®...');
  const scraper = new AnTuTuScraper();
  const data = await scraper.scrapeRanking();
  // ä¿å­˜åˆ°æ•°æ®åº“
});

job.start();
```

### å‰ç«¯å¯¹æ¯”ç»„ä»¶

```typescript
// components/DeviceComparison.tsx
interface ComparisonProps {
  devices: Device[];
}

export function DeviceComparison({ devices }: ComparisonProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      {devices.map(device => (
        <div key={device.id} className="border rounded-lg p-4">
          <h3>{device.brand} {device.model}</h3>
          
          {/* é›·è¾¾å›¾å¯¹æ¯” */}
          <RadarChart
            data={[
              { name: 'CPU', value: device.benchmarks[0].cpuScore },
              { name: 'GPU', value: device.benchmarks[0].gpuScore },
              { name: 'Memory', value: device.benchmarks[0].memScore },
              { name: 'UX', value: device.benchmarks[0].uxScore },
            ]}
          />
          
          {/* è§„æ ¼å¯¹æ¯” */}
          <SpecTable specs={device} />
        </div>
      ))}
    </div>
  );
}

// ä½¿ç”¨EChartsç»˜åˆ¶å¯¹æ¯”å›¾è¡¨
import * as echarts from 'echarts';

export function BenchmarkChart({ devices }: { devices: Device[] }) {
  const chartRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    if (!chartRef.current) return;
    
    const chart = echarts.init(chartRef.current);
    
    const option = {
      title: { text: 'æ€§èƒ½è·‘åˆ†å¯¹æ¯”' },
      tooltip: {},
      legend: {
        data: devices.map(d => `${d.brand} ${d.model}`)
      },
      xAxis: {
        type: 'category',
        data: ['AnTuTu', 'GeekBench å•æ ¸', 'GeekBench å¤šæ ¸', '3DMark']
      },
      yAxis: { type: 'value' },
      series: devices.map(device => ({
        name: `${device.brand} ${device.model}`,
        type: 'bar',
        data: [
          device.benchmarks.find(b => b.platform === 'AnTuTu')?.totalScore,
          device.benchmarks.find(b => b.platform === 'GeekBench')?.cpuScore,
          device.benchmarks.find(b => b.platform === 'GeekBench')?.gpuScore,
          device.benchmarks.find(b => b.platform === '3DMark')?.totalScore,
        ]
      }))
    };
    
    chart.setOption(option);
    
    return () => chart.dispose();
  }, [devices]);
  
  return <div ref={chartRef} className="w-full h-96" />;
}
```

---

## ğŸ¯ é¡¹ç›®ä¸‰ï¼šç›¸æœºåˆ†æå·¥å…·

### EXIFä¿¡æ¯æå–

```typescript
// ä½¿ç”¨exif-jsåº“
import EXIF from 'exif-js';

interface ExifData {
  // åŸºæœ¬ä¿¡æ¯
  make: string;              // åˆ¶é€ å•†
  model: string;             // å‹å·
  software: string;          // è½¯ä»¶ç‰ˆæœ¬
  
  // æ‹æ‘„å‚æ•°
  dateTime: string;          // æ‹æ‘„æ—¶é—´
  iso: number;               // ISO
  focalLength: string;       // ç„¦è·
  aperture: string;          // å…‰åœˆ
  shutterSpeed: string;      // å¿«é—¨é€Ÿåº¦
  exposureCompensation: number;
  
  // é•œå¤´ä¿¡æ¯
  lensModel: string;
  
  // GPS
  gps?: {
    latitude: number;
    longitude: number;
    altitude: number;
  };
  
  // å›¾åƒä¿¡æ¯
  width: number;
  height: number;
  orientation: number;
}

class ExifAnalyzer {
  async extractExif(file: File): Promise<ExifData> {
    return new Promise((resolve, reject) => {
      EXIF.getData(file as any, function(this: any) {
        const exifData = {
          make: EXIF.getTag(this, 'Make'),
          model: EXIF.getTag(this, 'Model'),
          iso: EXIF.getTag(this, 'ISOSpeedRatings'),
          focalLength: EXIF.getTag(this, 'FocalLength'),
          aperture: EXIF.getTag(this, 'FNumber'),
          shutterSpeed: EXIF.getTag(this, 'ExposureTime'),
          dateTime: EXIF.getTag(this, 'DateTime'),
          // ... æ›´å¤šå­—æ®µ
        };
        resolve(exifData as ExifData);
      });
    });
  }
}
```

### å›¾åƒè´¨é‡åˆ†æ

```typescript
// ä½¿ç”¨OpenCV.jsè¿›è¡Œå›¾åƒåˆ†æ
import cv from '@techstark/opencv-js';

class ImageQualityAnalyzer {
  // é”åº¦åˆ†æï¼ˆæ‹‰æ™®æ‹‰æ–¯æ–¹å·®ï¼‰
  async analyzeSharpness(imageData: ImageData): Promise<number> {
    const src = cv.matFromImageData(imageData);
    const gray = new cv.Mat();
    const laplacian = new cv.Mat();
    
    // è½¬ç°åº¦
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    
    // æ‹‰æ™®æ‹‰æ–¯ç®—å­
    cv.Laplacian(gray, laplacian, cv.CV_64F);
    
    // è®¡ç®—æ–¹å·®
    const mean = new cv.Mat();
    const stddev = new cv.Mat();
    cv.meanStdDev(laplacian, mean, stddev);
    
    const sharpness = stddev.data64F[0] * stddev.data64F[0];
    
    // æ¸…ç†
    src.delete();
    gray.delete();
    laplacian.delete();
    mean.delete();
    stddev.delete();
    
    return sharpness;
  }
  
  // å™ªç‚¹åˆ†æ
  async analyzeNoise(imageData: ImageData): Promise<number> {
    const src = cv.matFromImageData(imageData);
    const gray = new cv.Mat();
    const blur = new cv.Mat();
    const diff = new cv.Mat();
    
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
    cv.subtract(gray, blur, diff);
    
    const mean = new cv.Mat();
    const stddev = new cv.Mat();
    cv.meanStdDev(diff, mean, stddev);
    
    const noise = stddev.data64F[0];
    
    src.delete();
    gray.delete();
    blur.delete();
    diff.delete();
    mean.delete();
    stddev.delete();
    
    return noise;
  }
  
  // è‰²å½©åˆ†æ
  async analyzeColors(imageData: ImageData) {
    const src = cv.matFromImageData(imageData);
    const hsv = new cv.Mat();
    
    cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
    
    // è®¡ç®—è‰²å½©åˆ†å¸ƒç›´æ–¹å›¾
    const histSize = [50, 60];
    const ranges = [0, 180, 0, 256];
    const channels = [0, 1];
    const hist = new cv.Mat();
    const mask = new cv.Mat();
    
    cv.calcHist(
      new cv.MatVector([hsv]),
      channels,
      mask,
      hist,
      histSize,
      ranges
    );
    
    // åˆ†æè‰²å½©ä¸°å¯Œåº¦
    const colorfulness = this.calculateColorfulness(hist);
    
    src.delete();
    hsv.delete();
    hist.delete();
    mask.delete();
    
    return { colorfulness };
  }
  
  private calculateColorfulness(hist: cv.Mat): number {
    // åŸºäºç›´æ–¹å›¾è®¡ç®—è‰²å½©ä¸°å¯Œåº¦
    let sum = 0;
    let count = 0;
    
    for (let i = 0; i < hist.rows; i++) {
      for (let j = 0; j < hist.cols; j++) {
        const value = hist.floatAt(i, j);
        if (value > 0) {
          sum += value;
          count++;
        }
      }
    }
    
    return count / (hist.rows * hist.cols);
  }
}
```

### å¯¹æ¯”å·¥å…·

```typescript
interface ComparisonConfig {
  images: File[];
  metrics: ('sharpness' | 'noise' | 'colors' | 'exposure')[];
  exportFormat: 'image' | 'pdf' | 'json';
}

class ImageComparison {
  async compareImages(config: ComparisonConfig) {
    const analyzer = new ImageQualityAnalyzer();
    const results = [];
    
    for (const imageFile of config.images) {
      const imageData = await this.loadImage(imageFile);
      
      const result = {
        filename: imageFile.name,
        exif: await new ExifAnalyzer().extractExif(imageFile),
        metrics: {} as any
      };
      
      if (config.metrics.includes('sharpness')) {
        result.metrics.sharpness = await analyzer.analyzeSharpness(imageData);
      }
      
      if (config.metrics.includes('noise')) {
        result.metrics.noise = await analyzer.analyzeNoise(imageData);
      }
      
      if (config.metrics.includes('colors')) {
        result.metrics.colors = await analyzer.analyzeColors(imageData);
      }
      
      results.push(result);
    }
    
    return results;
  }
  
  // ç”Ÿæˆå¯¹æ¯”å›¾
  async generateComparisonImage(images: File[]) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    
    // è®¾ç½®ç”»å¸ƒå¤§å°ï¼ˆå¹¶æ’æ˜¾ç¤ºï¼‰
    const imageCount = images.length;
    const imageWidth = 800;
    const imageHeight = 600;
    
    canvas.width = imageWidth * imageCount;
    canvas.height = imageHeight;
    
    // åŠ è½½å¹¶ç»˜åˆ¶æ¯å¼ å›¾ç‰‡
    for (let i = 0; i < images.length; i++) {
      const img = await this.loadImageElement(images[i]);
      ctx.drawImage(img, i * imageWidth, 0, imageWidth, imageHeight);
      
      // æ·»åŠ æ ‡ç­¾
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.fillText(images[i].name, i * imageWidth + 10, 30);
    }
    
    return canvas.toDataURL('image/png');
  }
  
  private async loadImage(file: File): Promise<ImageData> {
    const img = await this.loadImageElement(file);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
  }
  
  private loadImageElement(file: File): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }
}
```

---

## ğŸ¯ é¡¹ç›®å››ï¼šæ¸¸æˆå¸§ç‡ç›‘æ§ï¼ˆAndroid Appï¼‰

### React Nativeå®ç°

```typescript
// App.tsx
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';
import { NativeModules } from 'react-native';

const { PerformanceMonitor } = NativeModules;

export function GameMonitor() {
  const [fps, setFps] = useState(0);
  const [cpuUsage, setCpuUsage] = useState(0);
  const [temperature, setTemperature] = useState(0);
  const [isMonitoring, setIsMonitoring] = useState(false);
  
  useEffect(() => {
    if (isMonitoring) {
      const interval = setInterval(async () => {
        const metrics = await PerformanceMonitor.getMetrics();
        setFps(metrics.fps);
        setCpuUsage(metrics.cpuUsage);
        setTemperature(metrics.temperature);
      }, 1000);
      
      return () => clearInterval(interval);
    }
  }, [isMonitoring]);
  
  return (
    <FloatingWindow>
      <Text>FPS: {fps}</Text>
      <Text>CPU: {cpuUsage}%</Text>
      <Text>æ¸©åº¦: {temperature}Â°C</Text>
    </FloatingWindow>
  );
}
```

### åŸç”ŸAndroidæ¨¡å—

```kotlin
// android/app/src/main/java/PerformanceMonitorModule.kt
package com.gamemonitor

import com.facebook.react.bridge.*
import android.view.Choreographer
import java.io.RandomAccessFile

class PerformanceMonitorModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {
    
    override fun getName() = "PerformanceMonitor"
    
    private var frameCallback: Choreographer.FrameCallback? = null
    private var lastFrameTime = 0L
    private var frameCount = 0
    private var fps = 0.0
    
    @ReactMethod
    fun startMonitoring(promise: Promise) {
        frameCallback = object : Choreographer.FrameCallback {
            override fun doFrame(frameTimeNanos: Long) {
                val currentTime = System.currentTimeMillis()
                frameCount++
                
                if (currentTime - lastFrameTime >= 1000) {
                    fps = frameCount.toDouble()
                    frameCount = 0
                    lastFrameTime = currentTime
                }
                
                Choreographer.getInstance().postFrameCallback(this)
            }
        }
        
        Choreographer.getInstance().postFrameCallback(frameCallback!!)
        promise.resolve(true)
    }
    
    @ReactMethod
    fun getMetrics(promise: Promise) {
        val metrics = Arguments.createMap()
        metrics.putDouble("fps", fps)
        metrics.putDouble("cpuUsage", getCPUUsage())
        metrics.putDouble("temperature", getTemperature())
        promise.resolve(metrics)
    }
    
    private fun getCPUUsage(): Double {
        try {
            val reader = RandomAccessFile("/proc/stat", "r")
            val line = reader.readLine()
            reader.close()
            
            val toks = line.split(" +".toRegex())
            val idle = toks[4].toLong()
            val total = toks.slice(1..7).sumOf { it.toLong() }
            
            return ((total - idle) * 100.0 / total)
        } catch (e: Exception) {
            return 0.0
        }
    }
    
    private fun getTemperature(): Double {
        try {
            val reader = RandomAccessFile("/sys/class/thermal/thermal_zone0/temp", "r")
            val temp = reader.readLine().toLong() / 1000.0
            reader.close()
            return temp
        } catch (e: Exception) {
            return 0.0
        }
    }
}
```

---

## ğŸ¯ é¡¹ç›®äº”ï¼šç”µæ± ç»­èˆªåˆ†æ

### Web Battery API

```typescript
interface BatteryManager {
  charging: boolean;
  chargingTime: number;
  dischargingTime: number;
  level: number;
  addEventListener(type: string, listener: EventListener): void;
}

class BatteryMonitor {
  private battery: BatteryManager | null = null;
  private dataPoints: BatteryDataPoint[] = [];
  
  async init() {
    this.battery = await (navigator as any).getBattery();
    this.startMonitoring();
  }
  
  private startMonitoring() {
    if (!this.battery) return;
    
    // è®°å½•åˆå§‹çŠ¶æ€
    this.recordDataPoint();
    
    // ç›‘å¬ç”µé‡å˜åŒ–
    this.battery.addEventListener('levelchange', () => {
      this.recordDataPoint();
    });
    
    // ç›‘å¬å……ç”µçŠ¶æ€å˜åŒ–
    this.battery.addEventListener('chargingchange', () => {
      this.recordDataPoint();
    });
    
    // å®šæ—¶è®°å½•ï¼ˆæ¯åˆ†é’Ÿï¼‰
    setInterval(() => {
      this.recordDataPoint();
    }, 60000);
  }
  
  private recordDataPoint() {
    if (!this.battery) return;
    
    const dataPoint: BatteryDataPoint = {
      timestamp: Date.now(),
      level: this.battery.level * 100,
      charging: this.battery.charging,
      chargingTime: this.battery.chargingTime,
      dischargingTime: this.battery.dischargingTime
    };
    
    this.dataPoints.push(dataPoint);
    this.saveToLocalStorage();
  }
  
  // è®¡ç®—å……ç”µé€Ÿåº¦
  getChargingSpeed(): number {
    const chargingPoints = this.dataPoints
      .filter(p => p.charging)
      .slice(-10); // æœ€è¿‘10ä¸ªæ•°æ®ç‚¹
    
    if (chargingPoints.length < 2) return 0;
    
    const first = chargingPoints[0];
    const last = chargingPoints[chargingPoints.length - 1];
    
    const timeDiff = (last.timestamp - first.timestamp) / 1000 / 60; // åˆ†é’Ÿ
    const levelDiff = last.level - first.level;
    
    return levelDiff / timeDiff; // %/min
  }
  
  // é¢„æµ‹å‰©ä½™æ—¶é—´
  predictRemainingTime(): number {
    const dischargingPoints = this.dataPoints
      .filter(p => !p.charging)
      .slice(-20);
    
    if (dischargingPoints.length < 2) return 0;
    
    // çº¿æ€§å›å½’é¢„æµ‹
    const speed = this.calculateDischargeRate(dischargingPoints);
    const currentLevel = this.battery?.level || 0;
    
    return (currentLevel * 100) / speed; // åˆ†é’Ÿ
  }
  
  private calculateDischargeRate(points: BatteryDataPoint[]): number {
    // ç®€å•çš„çº¿æ€§å›å½’
    const n = points.length;
    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    
    points.forEach((point, i) => {
      const x = i;
      const y = point.level;
      sumX += x;
      sumY += y;
      sumXY += x * y;
      sumX2 += x * x;
    });
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    return Math.abs(slope);
  }
  
  // ç”ŸæˆæŠ¥å‘Š
  generateReport() {
    return {
      totalDataPoints: this.dataPoints.length,
      averageChargingSpeed: this.getAverageChargingSpeed(),
      averageDischargeRate: this.getAverageDischargeRate(),
      chargingCycles: this.countChargingCycles(),
      batteryHealth: this.estimateBatteryHealth()
    };
  }
  
  private getAverageChargingSpeed(): number {
    // å®ç°...
    return 0;
  }
  
  private getAverageDischargeRate(): number {
    // å®ç°...
    return 0;
  }
  
  private countChargingCycles(): number {
    let cycles = 0;
    let wasCharging = false;
    
    this.dataPoints.forEach(point => {
      if (point.charging && !wasCharging) {
        cycles++;
      }
      wasCharging = point.charging;
    });
    
    return cycles;
  }
  
  private estimateBatteryHealth(): number {
    // åŸºäºæ”¾ç”µæ›²çº¿ä¼°ç®—ç”µæ± å¥åº·åº¦
    // è¿™éœ€è¦é•¿æœŸæ•°æ®ç§¯ç´¯
    return 100;
  }
  
  private saveToLocalStorage() {
    localStorage.setItem('batteryData', JSON.stringify(this.dataPoints));
  }
}

interface BatteryDataPoint {
  timestamp: number;
  level: number;
  charging: boolean;
  chargingTime: number;
  dischargingTime: number;
}
```

### å……ç”µæ›²çº¿å¯è§†åŒ–

```typescript
import { Line } from 'react-chartjs-2';

export function ChargingCurve({ data }: { data: BatteryDataPoint[] }) {
  const chartData = {
    labels: data.map(d => new Date(d.timestamp).toLocaleTimeString()),
    datasets: [
      {
        label: 'ç”µé‡ (%)',
        data: data.map(d => d.level),
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }
    ]
  };
  
  const options = {
    responsive: true,
    plugins: {
      title: {
        display: true,
        text: 'å……ç”µæ›²çº¿'
      },
      annotation: {
        annotations: {
          line1: {
            type: 'line',
            yMin: 80,
            yMax: 80,
            borderColor: 'rgb(255, 99, 132)',
            borderWidth: 2,
            label: {
              content: '80%ä¿æŠ¤å……ç”µ',
              enabled: true
            }
          }
        }
      }
    },
    scales: {
      y: {
        beginAtZero: true,
        max: 100,
        title: {
          display: true,
          text: 'ç”µé‡ (%)'
        }
      },
      x: {
        title: {
          display: true,
          text: 'æ—¶é—´'
        }
      }
    }
  };
  
  return <Line data={chartData} options={options} />;
}
```

---

## ğŸ”§ é€šç”¨æŠ€æœ¯ç»„ä»¶

### 1. æ•°æ®å¯è§†åŒ–ç»„ä»¶åº“

```typescript
// packages/ui/src/charts/index.ts

export { RadarChart } from './RadarChart';
export { LineChart } from './LineChart';
export { BarChart } from './BarChart';
export { HeatMap } from './HeatMap';

// RadarChart.tsx
import * as echarts from 'echarts';

interface RadarChartProps {
  data: Array<{
    name: string;
    value: number;
  }>;
  max?: number;
}

export function RadarChart({ data, max = 100 }: RadarChartProps) {
  const chartRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    if (!chartRef.current) return;
    
    const chart = echarts.init(chartRef.current);
    
    const option = {
      radar: {
        indicator: data.map(item => ({
          name: item.name,
          max: max
        }))
      },
      series: [{
        type: 'radar',
        data: [{
          value: data.map(item => item.value),
          name: 'æ€§èƒ½'
        }]
      }]
    };
    
    chart.setOption(option);
    
    return () => chart.dispose();
  }, [data, max]);
  
  return <div ref={chartRef} className="w-full h-64" />;
}
```

### 2. è®¾å¤‡ä¿¡æ¯æ£€æµ‹

```typescript
// packages/utils/src/deviceDetector.ts

export interface DeviceInfo {
  // æµè§ˆå™¨ä¿¡æ¯
  userAgent: string;
  browser: {
    name: string;
    version: string;
  };
  
  // æ“ä½œç³»ç»Ÿ
  os: {
    name: string;
    version: string;
  };
  
  // è®¾å¤‡ç±»å‹
  deviceType: 'mobile' | 'tablet' | 'desktop';
  
  // å±å¹•ä¿¡æ¯
  screen: {
    width: number;
    height: number;
    pixelRatio: number;
    colorDepth: number;
    orientation: 'portrait' | 'landscape';
  };
  
  // ç¡¬ä»¶ä¿¡æ¯
  hardware: {
    cpuCores: number;
    memory: number; // GB
    gpu?: string;
  };
  
  // ç½‘ç»œä¿¡æ¯
  network?: {
    type: string;
    effectiveType: string;
    downlink: number;
    rtt: number;
  };
}

export class DeviceDetector {
  static getDeviceInfo(): DeviceInfo {
    return {
      userAgent: navigator.userAgent,
      browser: this.detectBrowser(),
      os: this.detectOS(),
      deviceType: this.detectDeviceType(),
      screen: this.getScreenInfo(),
      hardware: this.getHardwareInfo(),
      network: this.getNetworkInfo()
    };
  }
  
  private static detectBrowser() {
    const ua = navigator.userAgent;
    let name = 'Unknown';
    let version = 'Unknown';
    
    if (ua.includes('Chrome')) {
      name = 'Chrome';
      version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Unknown';
    } else if (ua.includes('Firefox')) {
      name = 'Firefox';
      version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Unknown';
    } else if (ua.includes('Safari')) {
      name = 'Safari';
      version = ua.match(/Version\/(\d+)/)?.[1] || 'Unknown';
    }
    
    return { name, version };
  }
  
  private static detectOS() {
    const ua = navigator.userAgent;
    let name = 'Unknown';
    let version = 'Unknown';
    
    if (ua.includes('Android')) {
      name = 'Android';
      version = ua.match(/Android (\d+)/)?.[1] || 'Unknown';
    } else if (ua.includes('iPhone') || ua.includes('iPad')) {
      name = 'iOS';
      version = ua.match(/OS (\d+)/)?.[1] || 'Unknown';
    } else if (ua.includes('Windows')) {
      name = 'Windows';
    } else if (ua.includes('Mac')) {
      name = 'macOS';
    }
    
    return { name, version };
  }
  
  private static detectDeviceType(): 'mobile' | 'tablet' | 'desktop' {
    const width = window.innerWidth;
    
    if (width < 768) return 'mobile';
    if (width < 1024) return 'tablet';
    return 'desktop';
  }
  
  private static getScreenInfo() {
    return {
      width: screen.width,
      height: screen.height,
      pixelRatio: window.devicePixelRatio,
      colorDepth: screen.colorDepth,
      orientation: screen.orientation?.type.includes('portrait') ? 'portrait' : 'landscape'
    };
  }
  
  private static getHardwareInfo() {
    return {
      cpuCores: navigator.hardwareConcurrency || 0,
      memory: (navigator as any).deviceMemory || 0,
      gpu: this.detectGPU()
    };
  }
  
  private static detectGPU(): string | undefined {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl');
    
    if (!gl) return undefined;
    
    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    if (!debugInfo) return undefined;
    
    return gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
  }
  
  private static getNetworkInfo() {
    const connection = (navigator as any).connection;
    
    if (!connection) return undefined;
    
    return {
      type: connection.type,
      effectiveType: connection.effectiveType,
      downlink: connection.downlink,
      rtt: connection.rtt
    };
  }
}
```

### 3. æ•°æ®å¯¼å‡ºåŠŸèƒ½

```typescript
// packages/utils/src/exporters.ts

export class DataExporter {
  // å¯¼å‡ºä¸ºJSON
  static exportJSON(data: any, filename: string) {
    const json = JSON.stringify(data, null, 2);
    this.downloadFile(json, filename, 'application/json');
  }
  
  // å¯¼å‡ºä¸ºCSV
  static exportCSV(data: any[], filename: string) {
    if (data.length === 0) return;
    
    const headers = Object.keys(data[0]);
    const csv = [
      headers.join(','),
      ...data.map(row =>
        headers.map(header => {
          const value = row[header];
          return typeof value === 'string' && value.includes(',')
            ? `"${value}"`
            : value;
        }).join(',')
      )
    ].join('\n');
    
    this.downloadFile(csv, filename, 'text/csv');
  }
  
  // å¯¼å‡ºä¸ºPDF
  static async exportPDF(element: HTMLElement, filename: string) {
    const html2pdf = (await import('html2pdf.js')).default;
    
    const options = {
      margin: 10,
      filename: filename,
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { scale: 2 },
      jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
    };
    
    html2pdf().set(options).from(element).save();
  }
  
  // å¯¼å‡ºä¸ºå›¾ç‰‡
  static async exportImage(element: HTMLElement, filename: string) {
    const html2canvas = (await import('html2canvas')).default;
    const canvas = await html2canvas(element);
    
    canvas.toBlob(blob => {
      if (!blob) return;
      this.downloadBlob(blob, filename, 'image/png');
    });
  }
  
  private static downloadFile(content: string, filename: string, mimeType: string) {
    const blob = new Blob([content], { type: mimeType });
    this.downloadBlob(blob, filename, mimeType);
  }
  
  private static downloadBlob(blob: Blob, filename: string, mimeType: string) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}
```

---

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### Verceléƒ¨ç½²ï¼ˆæ¨èï¼‰

```bash
# å®‰è£…Vercel CLI
pnpm add -g vercel

# éƒ¨ç½²
vercel

# ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
vercel --prod
```

### Dockeréƒ¨ç½²

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# å®‰è£…pnpm
RUN npm install -g pnpm

FROM base AS dependencies
WORKDIR /app
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY apps/web/package.json ./apps/web/
COPY packages/*/package.json ./packages/
RUN pnpm install --frozen-lockfile

FROM base AS build
WORKDIR /app
COPY . .
COPY --from=dependencies /app/node_modules ./node_modules
RUN pnpm build

FROM base AS runtime
WORKDIR /app

COPY --from=build /app/apps/web/.next ./apps/web/.next
COPY --from=build /app/apps/web/public ./apps/web/public
COPY --from=build /app/node_modules ./node_modules
COPY --from=build /app/package.json ./

EXPOSE 3000
CMD ["pnpm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/mydb
    depends_on:
      - db
  
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### å›¾åƒå¤„ç†ä¼˜åŒ–

```typescript
// ä½¿ç”¨Web Workerå¤„ç†å›¾åƒ
// workers/imageProcessor.worker.ts
self.addEventListener('message', async (e) => {
  const { type, imageData } = e.data;
  
  switch (type) {
    case 'analyze':
      const result = await analyzeImage(imageData);
      self.postMessage({ type: 'result', data: result });
      break;
  }
});

// ä¸»çº¿ç¨‹ä½¿ç”¨
const worker = new Worker(new URL('./imageProcessor.worker.ts', import.meta.url));

worker.postMessage({
  type: 'analyze',
  imageData: imageData
});

worker.addEventListener('message', (e) => {
  if (e.data.type === 'result') {
    console.log('åˆ†æç»“æœ:', e.data.data);
  }
});
```

### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä½¿ç”¨ç´¢å¼•
model Device {
  @@index([brand, model])
  @@index([chipsetId])
  @@index([releaseDate])
}

// ä½¿ç”¨æŸ¥è¯¢ä¼˜åŒ–
const devices = await prisma.device.findMany({
  where: {
    brand: 'Apple',
    price: {
      gte: 5000,
      lte: 10000
    }
  },
  include: {
    chipset: true,
    benchmarks: {
      where: {
        platform: 'AnTuTu'
      },
      take: 1,
      orderBy: {
        createdAt: 'desc'
      }
    }
  },
  take: 10,
  skip: 0
});
```

---

## ğŸ” å®‰å…¨è€ƒè™‘

```typescript
// APIè·¯ç”±ä¿æŠ¤
import { rateLimit } from '@/lib/rate-limit';

const limiter = rateLimit({
  interval: 60 * 1000, // 1åˆ†é’Ÿ
  uniqueTokenPerInterval: 500
});

export async function POST(request: Request) {
  try {
    await limiter.check(request, 10); // æ¯åˆ†é’Ÿæœ€å¤š10æ¬¡è¯·æ±‚
    
    // å¤„ç†è¯·æ±‚...
    
  } catch {
    return new Response('Too Many Requests', { status: 429 });
  }
}

// è¾“å…¥éªŒè¯
import { z } from 'zod';

const DeviceSchema = z.object({
  brand: z.string().min(1).max(50),
  model: z.string().min(1).max(100),
  price: z.number().positive().optional(),
  chipsetId: z.string().cuid()
});

export async function createDevice(data: unknown) {
  const validated = DeviceSchema.parse(data);
  // åˆ›å»ºè®¾å¤‡...
}
```

---

è¿™ä»½æŠ€æœ¯æ–‡æ¡£æ¶µç›–äº†æ‰€æœ‰é¡¹ç›®çš„è¯¦ç»†å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ä»£ç ç¤ºä¾‹ã€æ•°æ®åº“è®¾è®¡ã€APIè®¾è®¡ç­‰ã€‚ä½ å¯ä»¥åŸºäºè¿™äº›æ–¹æ¡ˆç›´æ¥å¼€å§‹å¼€å‘ï¼
