import { BrowserWindow, ipcMain } from 'electron'
import * as fs from 'fs'
import * as path from 'path'

export interface ReportData {
  sessionId: string
  appName: string
  deviceName: string
  startTime: number
  endTime: number
  avgFps: number
  minFps: number
  maxFps: number
  fps1Low: number
  fps01Low: number
  jankCount: number
  avgCpuUsage: number
  avgGpuUsage: number
  avgTemperature: number
  avgPower: number
  fpsRecords: Array<{
    timestamp: number
    fps: number
    cpuUsage: number
    temperature: number
  }>
}

export interface ExportOptions {
  format: 'pdf' | 'html' | 'png'
  outputPath: string
  includeCharts: boolean
  includeRawData: boolean
}

export class PdfReportGenerator {
  private templatePath: string

  constructor() {
    this.templatePath = path.join(__dirname, 'templates')
  }

  async generatePdfReport(data: ReportData, outputPath: string): Promise<boolean> {
    try {
      const htmlContent = this.generateHtmlReport(data)
      
      const win = new BrowserWindow({
        width: 800,
        height: 600,
        show: false,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true
        }
      })

      await win.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(htmlContent)}`)

      const pdfBuffer = await win.webContents.printToPDF({
        marginsType: 0,
        printBackground: true,
        printSelectionOnly: false,
        landscape: false,
        pageSize: 'A4'
      })

      fs.writeFileSync(outputPath, pdfBuffer)
      win.close()

      return true
    } catch (error) {
      console.error('PDF generation error:', error)
      return false
    }
  }

  generateHtmlReport(data: ReportData): string {
    const duration = Math.round((data.endTime - data.startTime) / 1000)
    const startDate = new Date(data.startTime).toLocaleString()

    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>FPSæ€§èƒ½æµ‹è¯•æŠ¥å‘Š</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 40px;
      background: #fff;
      color: #333;
    }
    .header {
      text-align: center;
      margin-bottom: 40px;
      border-bottom: 2px solid #3b82f6;
      padding-bottom: 20px;
    }
    .header h1 { color: #1e40af; font-size: 28px; }
    .header p { color: #6b7280; margin-top: 10px; }
    .section { margin-bottom: 30px; }
    .section h2 { 
      color: #1e40af; 
      font-size: 18px; 
      margin-bottom: 15px;
      border-left: 4px solid #3b82f6;
      padding-left: 10px;
    }
    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
    }
    .info-item {
      background: #f8fafc;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    .info-item label { 
      color: #6b7280; 
      font-size: 12px; 
      display: block;
      margin-bottom: 5px;
    }
    .info-item .value { 
      font-size: 24px; 
      font-weight: bold; 
      color: #1e40af;
    }
    .info-item .unit { 
      font-size: 14px; 
      color: #6b7280;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
    }
    .stat-card {
      background: linear-gradient(135deg, #3b82f6, #1e40af);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    .stat-card .value { 
      font-size: 32px; 
      font-weight: bold;
    }
    .stat-card .label { 
      font-size: 12px;
      opacity: 0.8;
      margin-top: 5px;
    }
    .summary-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    .summary-table th, .summary-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }
    .summary-table th {
      background: #f8fafc;
      color: #374151;
      font-weight: 600;
    }
    .footer {
      margin-top: 40px;
      text-align: center;
      color: #9ca3af;
      font-size: 12px;
      border-top: 1px solid #e2e8f0;
      padding-top: 20px;
    }
    .performance-bar {
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 8px;
    }
    .performance-bar .fill {
      height: 100%;
      background: linear-gradient(90deg, #22c55e, #3b82f6);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ“Š FPSæ€§èƒ½æµ‹è¯•æŠ¥å‘Š</h1>
    <p>Generated by FPS Monitor Desktop</p>
  </div>

  <div class="section">
    <h2>ğŸ“± æµ‹è¯•ä¿¡æ¯</h2>
    <div class="info-grid">
      <div class="info-item">
        <label>åº”ç”¨åç§°</label>
        <div class="value" style="font-size: 18px;">${data.appName}</div>
      </div>
      <div class="info-item">
        <label>è®¾å¤‡åç§°</label>
        <div class="value" style="font-size: 18px;">${data.deviceName}</div>
      </div>
      <div class="info-item">
        <label>æµ‹è¯•å¼€å§‹æ—¶é—´</label>
        <div class="value" style="font-size: 16px;">${startDate}</div>
      </div>
      <div class="info-item">
        <label>æµ‹è¯•æ—¶é•¿</label>
        <div class="value">${duration}<span class="unit"> ç§’</span></div>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>ğŸ“ˆ å¸§ç‡ç»Ÿè®¡</h2>
    <div class="stats-grid">
      <div class="stat-card">
        <div class="value">${data.avgFps.toFixed(1)}</div>
        <div class="label">å¹³å‡å¸§ç‡ (FPS)</div>
      </div>
      <div class="stat-card" style="background: linear-gradient(135deg, #22c55e, #16a34a);">
        <div class="value">${data.maxFps.toFixed(1)}</div>
        <div class="label">æœ€é«˜å¸§ç‡ (FPS)</div>
      </div>
      <div class="stat-card" style="background: linear-gradient(135deg, #ef4444, #dc2626);">
        <div class="value">${data.minFps.toFixed(1)}</div>
        <div class="label">æœ€ä½å¸§ç‡ (FPS)</div>
      </div>
      <div class="stat-card" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
        <div class="value">${data.jankCount}</div>
        <div class="label">å¡é¡¿æ¬¡æ•°</div>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>ğŸ“‹ è¯¦ç»†æ•°æ®</h2>
    <table class="summary-table">
      <tr>
        <th>æŒ‡æ ‡</th>
        <th>æ•°å€¼</th>
        <th>è¯´æ˜</th>
      </tr>
      <tr>
        <td>1% Low FPS</td>
        <td><strong>${data.fps1Low.toFixed(1)} FPS</strong></td>
        <td>æœ€å·®1%å¸§çš„å¹³å‡å¸§ç‡</td>
      </tr>
      <tr>
        <td>0.1% Low FPS</td>
        <td><strong>${data.fps01Low.toFixed(1)} FPS</strong></td>
        <td>æœ€å·®0.1%å¸§çš„å¹³å‡å¸§ç‡</td>
      </tr>
      <tr>
        <td>å¹³å‡CPUå ç”¨</td>
        <td><strong>${data.avgCpuUsage.toFixed(1)}%</strong></td>
        <td>æµ‹è¯•æœŸé—´CPUå¹³å‡ä½¿ç”¨ç‡</td>
      </tr>
      <tr>
        <td>å¹³å‡GPUå ç”¨</td>
        <td><strong>${data.avgGpuUsage.toFixed(1)}%</strong></td>
        <td>æµ‹è¯•æœŸé—´GPUå¹³å‡ä½¿ç”¨ç‡</td>
      </tr>
      <tr>
        <td>å¹³å‡æ¸©åº¦</td>
        <td><strong>${data.avgTemperature.toFixed(1)}Â°C</strong></td>
        <td>è®¾å¤‡å¹³å‡æ¸©åº¦</td>
      </tr>
      <tr>
        <td>å¹³å‡åŠŸè€—</td>
        <td><strong>${data.avgPower.toFixed(2)} W</strong></td>
        <td>ä¼°ç®—å¹³å‡åŠŸè€—</td>
      </tr>
    </table>
  </div>

  <div class="section">
    <h2>ğŸ¯ æ€§èƒ½è¯„åˆ†</h2>
    <div class="info-item">
      <label>æµç•…åº¦è¯„åˆ†</label>
      <div class="value">${this.calculateScore(data)}<span class="unit"> / 100</span></div>
      <div class="performance-bar">
        <div class="fill" style="width: ${this.calculateScore(data)}%"></div>
      </div>
    </div>
  </div>

  <div class="footer">
    <p>æŠ¥å‘Šç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}</p>
    <p>FPS Monitor - ä¸“ä¸šæ¸¸æˆæ€§èƒ½æµ‹è¯•å·¥å…·</p>
  </div>
</body>
</html>`
  }

  private calculateScore(data: ReportData): number {
    let score = 100
    
    // åŸºäºå¹³å‡å¸§ç‡è¯„åˆ† (ç›®æ ‡60fps)
    if (data.avgFps < 60) {
      score -= (60 - data.avgFps) * 1.5
    }
    
    // åŸºäºå¸§ç‡ç¨³å®šæ€§è¯„åˆ†
    const stability = data.fps1Low / data.avgFps
    if (stability < 0.8) {
      score -= (0.8 - stability) * 50
    }
    
    // åŸºäºå¡é¡¿æ¬¡æ•°è¯„åˆ†
    score -= data.jankCount * 2
    
    // åŸºäºæ¸©åº¦è¯„åˆ†
    if (data.avgTemperature > 45) {
      score -= (data.avgTemperature - 45) * 2
    }
    
    return Math.max(0, Math.min(100, Math.round(score)))
  }

  async exportChartAsImage(chartElement: string, outputPath: string): Promise<boolean> {
    try {
      const win = new BrowserWindow({
        width: 800,
        height: 400,
        show: false,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true
        }
      })

      await win.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(chartElement)}`)
      
      const image = await win.webContents.capturePage()
      fs.writeFileSync(outputPath, image.toPNG())
      win.close()

      return true
    } catch (error) {
      console.error('Chart export error:', error)
      return false
    }
  }
}

export function setupPdfReportHandlers(): void {
  const generator = new PdfReportGenerator()

  ipcMain.handle('generate-pdf-report', async (_, data: ReportData, outputPath: string) => {
    return generator.generatePdfReport(data, outputPath)
  })

  ipcMain.handle('generate-html-report', async (_, data: ReportData) => {
    return generator.generateHtmlReport(data)
  })

  ipcMain.handle('export-chart-image', async (_, chartHtml: string, outputPath: string) => {
    return generator.exportChartAsImage(chartHtml, outputPath)
  })
}
